Meanwhile, in a completely chaotic, confused, disordered, fluky, incidental... anarchic way, I am learning advanced Python techniques (NLP, facial recognition ...) but also fundamentals like the difference between a "tuple" and a "dictionnary". So it was logic that Python popped up in my mind to bring this randomness, given the complexity of doing the same thing in Bash, a language that I am far from mastering! Incidentally, this experiment proves me that Python is: Easy to read: Python is easy to read and most of the language makes sense at a glimpse. This makes finding issues a lot easier than more complicated languages. Portability: Python runs on many platforms and systems, meaning your programs can reach a wider audience. Two qualities that gave Python a serious advantage in what I am looking for: to create on-demand order or disorder ðŸ™‚ Order: when it comes to browsing, summarizing and indexing hundreds of texts in order to store them in a database itself MySQL and/or NoSQL. Disorder: when it comes to run tests in parallel, for example, and thereby overcome a bias linked to a sequential execution. Oddly, sometimes, Disorder proves to be more efficient and effective than Order. So, this post presents my quick researches on how-to handle random in Python. Having in mind that the final objective is to load randomly testing files that achieve a complete Backofficeâ€™s assessment without increasing errors into the process. By the way, it reveals a third and fourth Python qualities: Increasing productivity: how much work you can accomplish in a given time with few lines of code. Relieving boring stuff in "bullshit jobs". Thanks to David Graeber and Al Sweigart to have enabled me to create this "tuna-mayo-sandwich" concept. So, now, letâ€™s move on and show some code...


